import re
import os
import literals

from utility import subprocess_popen
from utility import slugify


class Tagging:
    def __init__(self, config):
        self.config = config
        self.encoding = literals.utf_8

    def _fix_coding_issue(self, line):
        try:
            decoded_line = line.decode(self.encoding)
        except:
            decoded_line = line
        finally:
            decoded_line = decoded_line.replace('â€™', '\'', )
        return decoded_line

    def _titlecase(self, s):
        return re.sub(r"[A-Za-z]+('[A-Za-z]+)?", lambda word: word.group(0).capitalize(), s)

    def get_album_tags_from_cuefile(self, cuefile_obj):
        config = self.config
        cuefile = cuefile_obj.cuefile
        encoding = config.cuefile_encoding
        tag_dict = dict()
        tag_dict[1] = dict()

        n_track = 0
        n_lossless_file = 0
        global_artist = None
        global_genre = None
        first_track_detected = False
        # detecting multiple lossless files
        lossless_files = dict()

        with open(cuefile, encoding=encoding) as cuefile_fd:
            for cuefile_line in cuefile_fd.readlines():
                title = None

                if config.args.year is None:
                    year_match = re.match(r'^ *\t*(REM )?DATE *\t*["\']?([0-9]*)["\']? *$', cuefile_line, re.IGNORECASE)
                    if year_match is not None:
                        year = year_match.group(2)
                        continue
                else:
                    year = config.args.year

                if config.args.performer is None:
                    artist_match = re.match(r'^ *\t*(REM )?PERFORMER *\t*["\'](.*)["\'] *$', cuefile_line, re.IGNORECASE)
                    if artist_match is not None:
                        artist = artist_match.group(2)
                        if first_track_detected:
                            track_tag_dict[literals.artist] = artist.title()
                        global_artist = artist.title()
                        continue
                else:
                    if first_track_detected:
                        track_tag_dict[literals.artist] = config.args.performer.title()
                    global_artist = config.args.performer.title()

                if config.args.genre is None:
                    genre_match = re.match(r'^ *\t*(REM )?GENRE *\t*["\'](.*)["\'] *$', cuefile_line, re.IGNORECASE)
                    if genre_match is not None:
                        genre = genre_match.group(2)
                        if first_track_detected:
                            track_tag_dict[literals.genre] = genre.title()
                        global_genre = genre.title()
                        continue
                else:
                    if first_track_detected:
                        track_tag_dict[literals.genre] = config.args.genre.title()
                    global_genre = config.args.genre.title()

                title_match = re.match(r'^ *\t*(REM )?TITLE *\t*["\'](.*)["\'] *$', cuefile_line, re.IGNORECASE)
                if title_match is not None:
                    if first_track_detected:
                        title = title_match.group(2)
                        track_tag_dict[literals.title] = title.title()
                        track_tag_dict[literals.outfile] = f'{n_track:02d} {slugify(title)}.m4a'
                    else:
                        if config.args.album is not None:
                            album = config.args.album.title()
                        else:
                            album = title_match.group(2)
                        continue
                elif config.args.album is not None:
                    album = config.args.album.title()
                    if first_track_detected:
                        track_tag_dict[literals.album] = album

                file_match = re.match(r'^ *\t*(REM )?TRACK .*$', cuefile_line, re.IGNORECASE)
                if file_match is not None:
                    first_track_detected = True
                    n_track += 1
                    tag_dict[1][n_track] = dict()
                    track_tag_dict = tag_dict[1][n_track]
                    track_tag_dict[literals.global_genre] = global_genre
                    track_tag_dict[literals.genre] = global_genre
                    track_tag_dict[literals.year] = year
                    track_tag_dict[literals.album] = album
                    track_tag_dict[literals.comment] = 'Generated by all new lossless2lossy.py!'
                    track_tag_dict[literals.disctotal] = '1'
                    track_tag_dict[literals.global_artist] = global_artist
                    track_tag_dict[literals.artist] = global_artist
                    track_tag_dict[literals.title] = ''
                    track_tag_dict[literals.infile] = ''
                    track_tag_dict[literals.outfile] = f'{n_track:02d} {slugify(title)}.m4a'
                    if config.args.cover is not None:
                        track_tag_dict[literals.cover] = config.args.cover
                    else:
                        track_tag_dict[literals.cover] = ''

                file_match = re.match(r'^ *\t*FILE *\t*"(.*)" *(WAVE)?(FLAC)?(APE)? *\t*$', cuefile_line, re.IGNORECASE)
                if file_match is not None:
                    n_lossless_file += 1
                    lossless_files[n_lossless_file] = file_match.group(1)

        lossless_files_len = len(lossless_files)

        if lossless_files_len == 0:
            print('malformed cuefile: no lossless file specified')
            exit(-1)
        elif lossless_files_len > 1:
            config.single_lossless_file = False
            if lossless_files_len != len(tag_dict[1]):
                print('malformed cuefile: number of lossless files differs from number of tracks')
                exit(-1)
            for track, lossless_file in lossless_files.items():
                lossless_file = os.path.join(os.path.dirname(os.path.abspath(cuefile)), lossless_file)
                filename, ext = os.path.splitext(lossless_file)
                tag_dict[1][track][literals.losslessfile] = lossless_file
                tag_dict[1][track][literals.infile] = filename + '.wav'
        else:
            config.single_lossless_file = True
            config.single_lossless_file_name = lossless_files[1]
            for track, track_dict in tag_dict[1].items():
                track_dict[literals.infile] = f'split-track{track:02d}.wav'

        return tag_dict

    def get_album_tags_from_dir(self):
        config = self.config
        cwd = os.getcwd()
        audio_source_files = [f for f in os.listdir(cwd) if f.endswith('.ape')
                              or f.endswith('.wv')
                              or f.endswith('.flac')
                              or f.endswith('.m4a')]
        tag_dict = dict()

        decode_stderr = list()
        for track_file in audio_source_files:

            if config.decoder == literals.ffmpeg:
                decode_cmd = config.other_tools[config.decoder].copy()
                decode_cmd.append('-i')
                decode_cmd.append(track_file)
                decode_cmd.append('-y')
                decode_cmd.append('-f')
                decode_cmd.append('ffmetadata')

                decode_subprocess = subprocess_popen(decode_cmd)
                decode_subprocess.wait()
                decode_stderr.append(decode_subprocess.stderr)
            else:
                raise NotImplementedError()

        track_idx = 0
        for track_file in audio_source_files:
            artist = None
            album = None
            year = None
            disc = 1
            disctotal = None
            title = None
            genre = None
            track = None
            filename, ext = os.path.splitext(track_file)
            converted_filename = filename + '.wav'

            if config.decoder == literals.ffmpeg:
                decode_output = decode_stderr[track_idx]

                for line in decode_output.readlines():
                    decoded_line = self._detect_tag_line_encoding(line)
                    decoded_line = self._fix_coding_issue(decoded_line)

                    if config.args.performer is None:
                        artist_match = re.match(r'^ +ARTIST +: +(.*)$', decoded_line, re.IGNORECASE)
                        if artist_match is not None:
                            artist = artist_match.group(1)
                            continue
                    else:
                        artist = config.args.performer

                    if config.args.album is None:
                        album_match = re.match(r'^ +ALBUM +: +(.*)$', decoded_line, re.IGNORECASE)
                        if album_match is not None:
                            album = album_match.group(1)
                            continue
                    else:
                        album = config.args.album

                    if config.args.year is None:
                        year_match = re.match(r' +DATE +: +([0-9][0-9][0-9][0-9]).?[0-9]?.?[0-9]?', decoded_line,
                                              re.IGNORECASE)
                        if year_match is not None:
                            year = int(year_match.group(1))
                            continue
                    else:
                        year = config.args.year

                    disc_match = re.match(r'^ +disc +: +([0-9]+)$', decoded_line, re.IGNORECASE)
                    if disc_match is not None:
                        disc = int(disc_match.group(1))
                        continue

                    disctotal_match = re.match(r'^ +DISCTOTAL +: +([0-9]+)$', decoded_line,
                                               re.IGNORECASE)
                    if disctotal_match is not None:
                        disctotal = int(disctotal_match.group(1))
                        continue

                    title_match = re.match(r'^ +title +: +(.*)$', decoded_line, re.IGNORECASE)
                    if title_match is not None:
                        title = title_match.group(1)
                        continue

                    if config.args.genre is None:
                        genre_match = re.match(r'^ +GENRE +: +(.*)$', decoded_line, re.IGNORECASE)
                        if genre_match is not None:
                            genre = genre_match.group(1)
                            continue
                    else:
                        genre = config.args.genre

                    track_match = re.match(r'^ +track +: +([0-9]+)/?[0-9]*$', decoded_line, re.IGNORECASE)
                    if track_match is not None:
                        track = int(track_match.group(1))
                        continue
            else:
                raise NotImplementedError()

            track_tag_dict = dict()
            track_tag_dict[literals.artist] = self._titlecase(artist.title())
            track_tag_dict[literals.album] = self._titlecase(album.title())
            track_tag_dict[literals.year] = year
            track_tag_dict[literals.title] = self._titlecase(title.title())
            track_tag_dict[literals.genre] = self._titlecase(genre.title())
            track_tag_dict[literals.comment] = 'Generated by all new lossless2lossy.py!'
            # disctotal is unused from now because infered by the size of the tag_dict dict
            track_tag_dict[literals.disctotal] = disctotal
            track_tag_dict[literals.losslessfile] = track_file
            track_tag_dict[literals.infile] = converted_filename
            track_tag_dict[literals.outfile] = f'{track:02d} {slugify(title)}.m4a'
            if disc not in tag_dict:
                tag_dict[disc] = dict()
            tag_dict[disc][track] = track_tag_dict
            track_idx += 1
            if config.args.cover is not None:
                track_tag_dict[literals.cover] = config.args.cover
            else:
                track_tag_dict[literals.cover] = ''

        config.single_lossless_file = False

        return tag_dict

    def _detect_tag_line_encoding(self, line):
        try:
            decoded_line = line.decode(self.encoding)
        except UnicodeDecodeError:
            encodings = (literals.utf_8, literals.cp1252, literals.windows_1252)
            for enc in encodings:
                try:
                    decoded_line = line.decode(enc)
                    self.encoding = enc
                    break
                except UnicodeDecodeError:
                    continue
        return decoded_line
